<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>/******************************************************************************
 *                                  Types                                     *
 ******************************************************************************/

 typedef struct {
     int x;
     int y;
 } position_t;

/******************************************************************************
 *                          Configuration Parameters                          *
 ******************************************************************************/

// Map size
const int N_COLS = 10; // x
const int N_ROWS = 10; // y

// Number of total cells, used when flatten out the map for the visualizer
const int N_CELLS = N_COLS * N_ROWS;

// Number of drones and their starting positions
const int N_DRONES = 2;
typedef int[0, N_DRONES-1] drone_id_t;
const position_t drones_starting_pos[N_DRONES] = {{3, 1}, {6, 6}};
const int N_v[N_DRONES] = {6, 6}; // Drones vision range
const int N_r[N_DRONES] = {2, 2}; // Drones movement side

// Number of survivors and their starting positions
const int N_SURVIVORS = 3;
typedef int[0, N_SURVIVORS-1] survivor_id_t;
const position_t survivors_starting_pos[N_SURVIVORS] = {{2, 1}, {4, 2}, {5, 8}};
const int T_zr[N_SURVIVORS] = {8, 8, 8}; // Zero reponders assistance duration
const int T_v[N_SURVIVORS] = {15, 15, 15}; // Time after which a survivor in need dies

// Number of first responders and their starting positions
const int N_FIRST_RESPONDERS = 2;
typedef int[0, N_FIRST_RESPONDERS-1] first_resp_id_t;
const position_t first_responders_starting_pos[N_FIRST_RESPONDERS] = {{2, 3}, {8, 5}};
const int T_fr[N_FIRST_RESPONDERS] = {5, 5}; // First reponders assistance duration

/******************************************************************************
 *                                 Constants                                  *
 ******************************************************************************/

// Map cell status enumeration
const int CELL_FIRST =      0;

const int CELL_EMPTY =      CELL_FIRST + 0;
const int CELL_FIRE =       CELL_FIRST + 1;
const int CELL_EXIT =       CELL_FIRST + 2;
const int CELL_FIRST_RESP = CELL_FIRST + 3;
const int CELL_SURVIVOR =   CELL_FIRST + 4;
const int CELL_ZERO_RESP =  CELL_FIRST + 5;
const int CELL_IN_NEED =    CELL_FIRST + 6;
const int CELL_ASSISTED =   CELL_FIRST + 7; // Survivor in need while being assisted (by either zero or first responders)
const int CELL_ASSISTING =  CELL_FIRST + 8; // First responder busy assisting a survivor

const int CELL_LAST =           CELL_ASSISTING;

/******************************************************************************
 *                              Global variables                              *
 ******************************************************************************/

// Maps
int[CELL_FIRST,CELL_LAST] map[N_COLS][N_ROWS];
bool drone_map[N_COLS][N_ROWS];

// Channels
broadcast chan init_done;                      // Global initializing channel
broadcast chan tick;                           // Global simulation tick channel
urgent chan zr_assist[N_COLS][N_ROWS];         // Used by drones to instruct survivors to act as zero responders and assist a survivor in need
chan call_fr[N_COLS][N_ROWS];                  // Used by drones to instruct survivors to go call a first responder
chan fr_assist[N_COLS][N_ROWS];                // Used by survivors to instruct first responders to assist a survivor in need
broadcast chan assist_success[N_COLS][N_ROWS]; // For signaling that an assistance was completed successfully

// Meta variables used to share target positions
meta position_t target_in_need;
meta position_t target_first_resp;

// Number of available first responders at any given moment
// Every first responder in the system increments this value during init
int available_fr;

/******************************************************************************
 *                             Utility functions                              *
 ******************************************************************************/

// Returns the maximum between the two given integers
int imax(int a, int b) {
    return (a &gt;= b) ? a : b;
}

// Returns the minimum between the two given integers
int imin(int a, int b) {
    return (a &lt;= b) ? a : b;
}

// Returns the interger value clamped to the range [lower, upper]
int iclamp(int value, int lower, int upper) {
    return imax(lower, imin(value, upper));
}

// Returns the distance between two points in the grid
int distance(int x1, int y1, int x2, int y2) {
    int x_distance = x1 - x2;
    int y_distance = y1 - y2;

    if (x_distance &lt; 0)
        x_distance = -x_distance;
    if (y_distance &lt; 0)
        y_distance = -y_distance;

    return imax(x_distance, y_distance);
}
</declaration>
	<template>
		<name>Initializer</name>
		<declaration>void init_assignment_example() {
    // Init the map will all empty cells
    for(x : int[0, N_ROWS-1])
        for(y : int[0, N_COLS-1]) {
            map[x][y] = CELL_EMPTY;
            drone_map[x][y] = false;
        }

    // Set fires
    map[5][1] = CELL_FIRE;
    map[6][1] = CELL_FIRE;
    map[5][2] = CELL_FIRE;
    map[6][2] = CELL_FIRE;
    map[4][3] = CELL_FIRE;
    map[5][3] = CELL_FIRE;
    map[6][3] = CELL_FIRE;
    map[4][4] = CELL_FIRE;
    map[5][4] = CELL_FIRE;

    // Set exits
    map[0][4] = CELL_EXIT;
    map[9][4] = CELL_EXIT;
    map[0][5] = CELL_EXIT;
    map[9][5] = CELL_EXIT;
}
</declaration>
		<location id="id0" x="213" y="0">
		</location>
		<location id="id1" x="42" y="0">
			<committed/>
		</location>
		<location id="id2" x="-221" y="0">
			<committed/>
		</location>
		<init ref="id2"/>
		<transition id="id3">
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="314" y="0">tick!</label>
			<nail x="306" y="-59"/>
			<nail x="306" y="51"/>
		</transition>
		<transition id="id4">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="59" y="0">init_done!</label>
		</transition>
		<transition id="id5">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="assignment" x="-204" y="0">init_assignment_example()</label>
		</transition>
	</template>
	<template>
		<name>Drone</name>
		<parameter>const drone_id_t id</parameter>
		<declaration>int x;
int y;

void init_state() {
    // Initialize position
    x = drones_starting_pos[id].x;
    y = drones_starting_pos[id].y;
}

int move_policy_next_move_idx = 0;

const int MOVE_POLICY_LEN = N_r[id] * 4;

void step_calculation(int &amp;next_x, int &amp;next_y) {
    if (move_policy_next_move_idx &lt; MOVE_POLICY_LEN / 4) // We have to move right
    {
        next_x += 1;
        next_y += 0;
    }
    else if (move_policy_next_move_idx &lt; 2 * MOVE_POLICY_LEN / 4) // We have to move up
    {
        next_x += 0;
        next_y += 1;
    }
    else if (move_policy_next_move_idx &lt; 3*MOVE_POLICY_LEN / 4) // We have to move left
    {
        next_x += -1;
        next_y += 0;
    }
    else if (move_policy_next_move_idx &lt; 4 * MOVE_POLICY_LEN / 4) // We have to move down
    {
        next_x += 0;
        next_y += -1;
    }

    move_policy_next_move_idx += 1;
    if(move_policy_next_move_idx &gt;= MOVE_POLICY_LEN)
    {
        move_policy_next_move_idx = 0;
    }
}

// Drone search bounds, updated at every move
int x_lower;
int x_upper;
int y_lower;
int y_upper;

void move_one_step() {
    // Update position
    drone_map[x][y] = false;
    step_calculation(x,y);
    drone_map[x][y] = true;

    x =  imax(x, 0); // check if we are out of the left side of the map
    x =  imin(x, N_COLS - 1); // check if we are out of the right side of the map
    y =  imax(y, 0); // check if we are out of the bottom side of the map
    y =  imin(y, N_ROWS - 1); // check if we are out of the top side of the map

    // Update search bounds
    x_lower = imax(x - N_v[id], 0);
    x_upper = imin(x + N_v[id], N_COLS - 1);
    y_lower = imax(y - N_v[id], 0);
    y_upper = imin(y + N_v[id], N_ROWS - 1);
}

// Survivor, Survivor-In-Need and First-Responder detection is done in a pipelined way
// Each stage of the pipeline saves the coordinates of the detected target into variables
// that are later used to make decisions about instructions the drone will give to the survivor

// Detected Survivor position
int s_x;
int s_y;

bool is_survivor(int xx, int yy) {
    // A survivor must be in the field of view
    return x_lower &lt;= xx &amp;&amp; xx &lt;= x_upper &amp;&amp;
           y_lower &lt;= yy &amp;&amp; yy &lt;= y_upper &amp;&amp;
           map[xx][yy] == CELL_SURVIVOR;
}

void set_survivor(int xx, int yy) {
    s_x = xx;
    s_y = yy;
    map[xx][yy] = CELL_ZERO_RESP;
}

void unset_survivor(){
    map[s_x][s_y] = CELL_SURVIVOR;
}

bool is_in_need(int xx, int yy) {
    return x_lower &lt;= xx &amp;&amp; xx &lt;= x_upper &amp;&amp;
           y_lower &lt;= yy &amp;&amp; yy &lt;= y_upper &amp;&amp;
           map[xx][yy] == CELL_IN_NEED;
}

void set_in_need(int xx, int yy) {
    target_in_need.x = xx;
    target_in_need.y = yy;
    map[xx][yy] = CELL_ASSISTED;
}

bool is_first_resp(int xx, int yy) {
    return map[xx][yy] == CELL_FIRST_RESP;
}

void set_first_resp(int xx, int yy) {
    target_first_resp.x = xx;
    target_first_resp.y = yy;
}

// Returns whether the drone is near a survivor in need and a moving survivor
// Used to control access to the decision-making locations
bool survivors_near() {
    int i, j;
    bool found_in_need = false;
    bool found_survivor = false;

    for (i = x_lower; i &lt;= x_upper; i += 1) {
        for (j = y_lower; j &lt;= y_upper; j += 1) {
            int cell = map[i][j];

            // Check map cell and update flags
            if (cell == CELL_IN_NEED)
                found_in_need = true;
            else if (cell == CELL_SURVIVOR)
                found_survivor = true;

            // Exit if we found an in_need cell and an survivor cell
            if (found_in_need &amp;&amp; found_survivor)
                return true;
        }
    }

    return false;
}


// Returns whether the drone is near a survivor in need
// Used to control access to the decision-making locations
bool in_need_near() {
       int i, j;

    for (i = x_lower; i &lt;= x_upper; i += 1) {
        for (j = y_lower; j &lt;= y_upper; j += 1) {
            int cell = map[i][j];

            // Check map cell and update flags
            if (cell == CELL_IN_NEED)
                return true;
        }
    }

    return false;
}

// Returns whether a first responder should be called to assist a survivor in need
bool prefer_fr(int xx, int yy, int xf, int yf) {
    // Greedy approach: prefer the minimum time to safety

    bool is_fr_available = available_fr &gt; 0;

    int dist = distance(xx, yy, xf, yf);

    return is_fr_available;
}

bool prefer_zr() {
    return true;
}
</declaration>
		<location id="id6" x="-1087" y="-433">
			<name x="-1070" y="-467">FoundFirstResp</name>
			<committed/>
		</location>
		<location id="id7" x="-799" y="-544">
			<name x="-782" y="-578">InstructZeroResp</name>
			<committed/>
		</location>
		<location id="id8" x="-798" y="-433">
			<name x="-781" y="-467">FindFirstResponder</name>
			<committed/>
		</location>
		<location id="id9" x="-425" y="-493">
			<name x="-671" y="-501">SurvivorAndInNeedSelected</name>
			<label kind="comments" x="-773" y="-399">If there is a first responder available,
instruct the selected zero reponder to
call him, otherwise assit directly</label>
			<committed/>
		</location>
		<location id="id10" x="-688" y="-799">
			<name x="-671" y="-833">SurvivorSelected</name>
			<committed/>
		</location>
		<location id="id11" x="-1589" y="-799">
		</location>
		<location id="id12" x="-1402" y="-799">
			<name x="-1385" y="-833">Moving</name>
		</location>
		<location id="id13" x="-1164" y="-799">
			<name x="-1147" y="-833">Scanning</name>
			<committed/>
		</location>
		<init ref="id11"/>
		<transition id="id14">
			<source ref="id10"/>
			<target ref="id13"/>
			<label kind="guard" x="-875" y="-892">!in_need_near()</label>
			<label kind="assignment" x="-875" y="-875">unset_survivor()</label>
			<nail x="-731" y="-850"/>
			<nail x="-1164" y="-850"/>
		</transition>
		<transition id="id15">
			<source ref="id6"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-1266" y="-433">call_fr[s_x][s_y]!</label>
			<nail x="-1428" y="-433"/>
			<nail x="-1428" y="-773"/>
		</transition>
		<transition id="id16">
			<source ref="id7"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-995" y="-544">zr_assist[s_x][s_y]!</label>
			<nail x="-1402" y="-544"/>
		</transition>
		<transition id="id17">
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="select" x="-1062" y="-433">xx : int[0, N_COLS-1],
yy : int[0, N_ROWS-1]</label>
			<label kind="guard" x="-1062" y="-391">is_first_resp(xx, yy)</label>
			<label kind="assignment" x="-1062" y="-374">set_first_resp(xx, yy)</label>
		</transition>
		<transition id="id18">
			<source ref="id9"/>
			<target ref="id7"/>
			<label kind="guard" x="-774" y="-544">available_fr == 0</label>
			<nail x="-476" y="-544"/>
		</transition>
		<transition id="id19">
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="guard" x="-773" y="-433">available_fr &gt; 0</label>
			<label kind="comments" x="-1589" y="-382">TODO: available_fr can
potentially be removed</label>
			<nail x="-476" y="-433"/>
		</transition>
		<transition id="id20">
			<source ref="id10"/>
			<target ref="id9"/>
			<label kind="select" x="-671" y="-799">xx : int[0, N_COLS-1],
yy : int[0, N_ROWS-1]</label>
			<label kind="guard" x="-671" y="-757">is_in_need(xx, yy)</label>
			<label kind="assignment" x="-671" y="-739">set_in_need(xx, yy)</label>
			<label kind="comments" x="-671" y="-714">Finds one in_need in the
field of view and saves
its coordinates</label>
			<nail x="-425" y="-799"/>
		</transition>
		<transition id="id21">
			<source ref="id13"/>
			<target ref="id10"/>
			<label kind="select" x="-1147" y="-799">xx : int[0, N_COLS-1],
yy : int[0, N_ROWS-1]</label>
			<label kind="guard" x="-1147" y="-756">is_survivor(xx, yy)</label>
			<label kind="synchronisation" x="-1147" y="-722">zr_assist[xx][yy]!</label>
			<label kind="assignment" x="-1147" y="-739">set_survivor(xx, yy)</label>
			<label kind="comments" x="-1147" y="-697">Finds one possible zero responder in
the field of view and saves its coordinates</label>
		</transition>
		<transition id="id22">
			<source ref="id13"/>
			<target ref="id12"/>
			<label kind="guard" x="-1360" y="-875">!survivors_near()</label>
			<nail x="-1207" y="-850"/>
			<nail x="-1402" y="-850"/>
		</transition>
		<transition id="id23">
			<source ref="id12"/>
			<target ref="id13"/>
			<label kind="synchronisation" x="-1385" y="-782">tick?</label>
			<label kind="assignment" x="-1385" y="-799">move_one_step()</label>
		</transition>
		<transition id="id24">
			<source ref="id11"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-1572" y="-799">init_done?</label>
			<label kind="assignment" x="-1572" y="-782">init_state()</label>
		</transition>
	</template>
	<template>
		<name>Survivor</name>
		<parameter>const survivor_id_t id</parameter>
		<declaration>clock t=0;

int x;
int y;

void init_state() {
    // Initialize position
    x = survivors_starting_pos[id].x;
    y = survivors_starting_pos[id].y;

    // Set position in the map
    map[x][y] = CELL_SURVIVOR;
}

// Distance from fire when this survivor becomes in need
const int FIRE_RADIUS = 1;

// Distance from exit when this survivor becomes in safe
const int EXIT_RADIUS = 1;

// Distance variable used to emulate the time taken for this survivor to perform grid movements
int move_time = 0;

// Target coordinates that this survivor should move to
int targ_x;
int targ_y;

// Coordinates of the first responder that this survivor must call
int fr_x;
int fr_y;

void do_zr_assist() {
    // Set assisted coords to notify the end of the assistance later
    targ_x = target_in_need.x;
    targ_y = target_in_need.y;

    // Set moving time
    move_time = distance(x, y, targ_x, targ_y);

    // Set our cell as zero responder
    map[x][y] = CELL_ZERO_RESP;

    // Set the in-need cell as being assisted
    map[targ_x][targ_y] = CELL_ASSISTED;
}

void do_call_fr() {
    // Set assisted coords to wait for the end of the first responder assistance
    targ_x = target_in_need.x;
    targ_y = target_in_need.y;

    // Set first responder coords to notify them of an assistance
    fr_x = target_first_resp.x;
    fr_y = target_first_resp.y;

    // Set the target coordinates for the first responder
    target_in_need.x = targ_x;
    target_in_need.y = targ_y;

    // Set moving time
    move_time = distance(x, y, fr_x, fr_y);

    // Set our cell as zero responder
    map[x][y] = CELL_ZERO_RESP;
}

bool is_fire_near(int xx, int yy) {
    int x_lower = imax(xx - FIRE_RADIUS, 0);
    int x_upper = imin(xx + FIRE_RADIUS, N_COLS - 1);
    int y_lower = imax(yy - FIRE_RADIUS, 0);
    int y_upper = imin(yy + FIRE_RADIUS, N_ROWS - 1);

    int i, j;
    for (i = x_lower; i &lt;= x_upper; i += 1)
        for (j = y_lower; j &lt;= y_upper; j += 1)
            if (map[i][j] == CELL_FIRE)
                return true;

    return false;
}

bool is_exit_near(int xx, int yy) {
    int x_lower = imax(xx - EXIT_RADIUS, 0);
    int x_upper = imin(xx + EXIT_RADIUS, N_COLS - 1);
    int y_lower = imax(yy - EXIT_RADIUS, 0);
    int y_upper = imin(yy + EXIT_RADIUS, N_ROWS - 1);

    int i, j;
    for (i = x_lower; i &lt;= x_upper; i += 1)
        for (j = y_lower; j &lt;= y_upper; j += 1)
            if (map[i][j] == CELL_EXIT)
                return true;

    return false;
}


void find_nearest_exit(int &amp;xx, int &amp;yy) {
    int exitDistance = imax(N_ROWS, N_COLS) + 1; // max value
    int i, j;

    for (i = 0; i &lt; N_COLS; i += 1) {
        for (j = 0; j &lt; N_ROWS; j += 1) {
            int cell = map[i][j];

            if (cell == CELL_EXIT) {
                int disTemp = distance(x, y, i, j);
                if (disTemp &lt;= exitDistance) {
                    xx = i;
                    yy = j;
                    exitDistance = disTemp;
                }
            }
        }
    }
}

bool is_move_valid(int xx, int yy) {
    bool valid = false;

    // We can only move inside the map
    if (0 &lt;= xx &amp;&amp; xx &lt;= N_COLS - 1 &amp;&amp; 0 &lt;= yy &amp;&amp; yy &lt;= N_ROWS - 1) {

        // At least one coordinate must change, the move cannot target the same position
        valid = xx != x || yy != y;

        // We cannot move near a fire
        valid &amp;= !is_fire_near(xx, yy);

        // We can move only towards empty cells
        valid &amp;= map[xx][yy] == CELL_EMPTY;
    }

    return valid;
}

int exit_x, exit_y; // the current exit we are trying to reach

/**
 * This moving policy tries to follow a direct path to the nearest exit.
 * When the next move on the direct path cannot be taken (the cell is
 * occupied or there is a fire near) we randomly choose a valid move.
 */
void move(int ii, int jj) {
    int next_x, next_y;
    int direction_x, direction_y;

    // Random function to prefer X half of the time
    bool prefer_x = (ii * jj) != 0;

    find_nearest_exit(exit_x, exit_y);

    // Tells what direction to move to over x to go towards the exit
    if (exit_x - x &gt; 0)
        direction_x = 1; // Right
    else if (exit_x - x &lt; 0)
        direction_x = -1; // Left
    else
        direction_x = 0; // Stay put

    // Same thing for y
    if (exit_y - y &gt; 0)
        direction_y = 1; // Down
    else if (exit_y - y &lt; 0)
        direction_y = -1; // Up
    else
        direction_y = 0; // Stay put

    // Compute the next optimal position towards the nearest exit
    next_x = x + direction_x;
    next_y = y + direction_y;

    // Set the current position empty because we'll move
    map[x][y] = CELL_EMPTY;

    if (is_move_valid(next_x, next_y)) {
        // We move to the optimal cell if the move is valid
        x = next_x;
        y = next_y;
    } else if (prefer_x) {
        // If we prefer X, try in order X -&gt; Y -&gt; random
        if (is_move_valid(next_x, y)) {
            // The optimal X direction is not null and is feasible
            x = next_x;
            y = y;
        } else if (is_move_valid(x, next_y)) {
            // The optimal Y direction is not null and is feasible
            x = x;
            y = next_y;
        } else {
            // Move in a random direction from the chosen transition
            x += ii;
            y += jj;
        }
    } else if (!prefer_x) {
        // If we prefer Y, try in order Y -&gt; X -&gt; random
        if (is_move_valid(x, next_y)) {
            // The optimal Y direction is not null and is feasible
            x = x;
            y = next_y;
        } else if (is_move_valid(next_x, next_y)) {
            // The optimal X direction is not null and is feasible
            x = next_x;
            y = y;
        } else if(is_move_valid(x+ii, y+jj)){
            // Move in a random direction from the chosen transition
            // We still have to check if the move is still valid or if it is occupied
            x += ii;
            y += jj;
        }
    }

    map[x][y] = CELL_SURVIVOR;
}
</declaration>
		<location id="id25" x="-161" y="85">
			<name x="-186" y="51">Moving</name>
		</location>
		<location id="id26" x="382" y="85">
			<name x="297" y="102">ActingZeroResponder</name>
		</location>
		<location id="id27" x="-382" y="85">
			<committed/>
		</location>
		<location id="id28" x="375" y="-262">
			<name x="350" y="-321">InNeed</name>
			<label kind="invariant" x="350" y="-304">t &lt;= T_v[id]</label>
		</location>
		<location id="id29" x="-637" y="85">
		</location>
		<location id="id30" x="681" y="-152">
			<name x="664" y="-194">Dead</name>
		</location>
		<location id="id31" x="1021" y="84">
			<name x="1045" y="75">Safe</name>
		</location>
		<location id="id32" x="348" y="348">
			<name x="255" y="306">LockFirstResponder</name>
			<committed/>
		</location>
		<location id="id33" x="-161" y="450">
			<name x="-195" y="467">Moved</name>
			<committed/>
		</location>
		<location id="id34" x="926" y="348">
		</location>
		<location id="id35" x="629" y="348">
			<name x="543" y="306">CallingFirstResponder</name>
			<label kind="invariant" x="604" y="391">t &lt;= move_time</label>
		</location>
		<location id="id36" x="17" y="255">
			<name x="8" y="272">AwaitingJob</name>
		</location>
		<init ref="id29"/>
		<transition id="id37">
			<source ref="id33"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="-136" y="425">zr_assist[x][y]?</label>
			<nail x="17" y="450"/>
		</transition>
		<transition id="id38">
			<source ref="id36"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="136" y="110">zr_assist[x][y]?</label>
			<label kind="assignment" x="136" y="127">do_zr_assist()</label>
		</transition>
		<transition id="id39">
			<source ref="id35"/>
			<target ref="id34"/>
			<label kind="guard" x="732" y="323">t &gt;= move_time</label>
			<label kind="synchronisation" x="724" y="306">fr_assist[fr_x][fr_y]!</label>
		</transition>
		<transition id="id40">
			<source ref="id34"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="654" y="178">assist_success[targ_x][targ_y]?</label>
			<label kind="assignment" x="654" y="195">map[x][y] = CELL_EMPTY</label>
			<nail x="926" y="136"/>
		</transition>
		<transition id="id41">
			<source ref="id33"/>
			<target ref="id25"/>
			<label kind="guard" x="-161" y="255">!is_exit_near(x,y)</label>
			<nail x="-161" y="306"/>
		</transition>
		<transition id="id42">
			<source ref="id33"/>
			<target ref="id31"/>
			<label kind="guard" x="280" y="578">is_exit_near(x,y)</label>
			<label kind="assignment" x="263" y="595">map[x][y] = CELL_EMPTY</label>
			<nail x="-161" y="569"/>
			<nail x="1011" y="569"/>
		</transition>
		<transition id="id43">
			<source ref="id30"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="758" y="-161">assist_success[x][y]?</label>
			<label kind="comments" x="554" y="-119">Consume signals to avoid deadlocking
the first/zero responder</label>
			<nail x="749" y="-178"/>
			<nail x="749" y="-127"/>
		</transition>
		<transition id="id44">
			<source ref="id28"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="545" y="-304">assist_success[x][y]?</label>
			<label kind="assignment" x="545" y="-288">map[x][y] = CELL_EMPTY</label>
			<nail x="1021" y="-256"/>
		</transition>
		<transition id="id45">
			<source ref="id32"/>
			<target ref="id35"/>
			<label kind="synchronisation" x="434" y="349">call_fr[fr_x][fr_y]!</label>
			<label kind="assignment" x="442" y="374">t = 0</label>
		</transition>
		<transition id="id46">
			<source ref="id36"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="127" y="323">call_fr[x][y]?</label>
			<label kind="assignment" x="127" y="340">do_call_fr()</label>
		</transition>
		<transition id="id47">
			<source ref="id28"/>
			<target ref="id30"/>
			<label kind="guard" x="401" y="-194">t &gt;= T_v[id]</label>
			<label kind="assignment" x="401" y="-177">map[x][y] = CELL_EMPTY</label>
			<nail x="375" y="-151"/>
		</transition>
		<transition id="id48">
			<source ref="id26"/>
			<target ref="id31"/>
			<label kind="guard" x="639" y="25">t &gt;= T_zr[id] + move_time</label>
			<label kind="synchronisation" x="639" y="42">assist_success[targ_x][targ_y]!</label>
			<label kind="assignment" x="639" y="59">map[x][y] = CELL_EMPTY</label>
		</transition>
		<transition id="id49">
			<source ref="id25"/>
			<target ref="id33"/>
			<label kind="select" x="-424" y="238">ii : int[-1, 1],
jj : int[-1, 1]</label>
			<label kind="guard" x="-424" y="281">is_move_valid(x + ii, y + jj)</label>
			<label kind="synchronisation" x="-407" y="221">tick?</label>
			<label kind="assignment" x="-424" y="298">move(ii,jj)</label>
			<nail x="-433" y="153"/>
			<nail x="-433" y="399"/>
		</transition>
		<transition id="id50">
			<source ref="id27"/>
			<target ref="id25"/>
			<label kind="guard" x="-357" y="59">!is_fire_near(x,y)</label>
		</transition>
		<transition id="id51">
			<source ref="id29"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-620" y="93">init_done?</label>
			<label kind="assignment" x="-620" y="110">init_state()</label>
		</transition>
		<transition id="id52">
			<source ref="id27"/>
			<target ref="id28"/>
			<label kind="guard" x="-374" y="-221">is_fire_near(x,y)</label>
			<label kind="assignment" x="-374" y="-204">map[x][y] = CELL_IN_NEED,
t = 0</label>
			<nail x="-382" y="-255"/>
		</transition>
		<transition id="id53">
			<source ref="id25"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="-127" y="59">zr_assist[x][y]?</label>
			<nail x="17" y="85"/>
		</transition>
	</template>
	<template>
		<name>FirstResponder</name>
		<parameter>const first_resp_id_t id</parameter>
		<declaration>clock t=0;

int x;
int y;

void init_state() {
    // Initialize position
    x = first_responders_starting_pos[id].x;
    y = first_responders_starting_pos[id].y;

    // Set position in the map
    map[x][y] = CELL_FIRST_RESP;

    // Register as an available first responder
    available_fr += 1;
}

// Distance variable used to emulate the time taken for this survivor to perform grid movements
int move_time = 0;

// Target coordinates that this survivor should move to
int targ_x;
int targ_y;

void do_fr_assist() {
    // Set assisted coords to notify the end of the assistance later
    targ_x = target_in_need.x;
    targ_y = target_in_need.y;

    // Set moving time
    move_time = distance(x, y, targ_x, targ_y);

    // Set our cell as busy first responder
    map[x][y] = CELL_ASSISTING;

    // Set the in-need cell as being assisted
    map[targ_x][targ_y] = CELL_ASSISTED;
}

void end_assist() {
    // Set our previous position as empty
    map[x][y] = CELL_EMPTY;

    // Teleport to the position of the survivor-in-need we just finished assisting
    x = targ_x;
    y = targ_y;

    // Set ourselves at the new position
    map[x][y] = CELL_FIRST_RESP;
}

bool is_move_valid(int xx, int yy) {
    bool valid = false;

    // We can only move inside the map
    if (0 &lt;= xx &amp;&amp; xx &lt;= N_COLS - 1 &amp;&amp; 0 &lt;= yy &amp;&amp; yy &lt;= N_ROWS - 1) {

        // At least one coordinate must change, the move cannot target the same position
        valid = xx != x || yy != y;

        // As a first responder we can move near a fire

        // We can move only towards empty cells
        valid &amp;= map[xx][yy] == CELL_EMPTY;
    }

    return valid;
}

void move(int ii, int jj) {

    if(is_move_valid(x+ii,y+jj)){
        map[x][y] = CELL_EMPTY;
        x += ii;
        y += jj;
        map[x][y] = CELL_FIRST_RESP;
    }
}</declaration>
		<location id="id54" x="170" y="-161">
			<name x="143" y="-203">Assisting</name>
			<label kind="invariant" x="187" y="-170">t &lt;= T_fr[id]</label>
		</location>
		<location id="id55" x="-552" y="-161">
			<name x="-544" y="-195">Available</name>
		</location>
		<location id="id56" x="-850" y="-161">
		</location>
		<location id="id57" x="-34" y="-161">
			<name x="-59" y="-203">Moving</name>
			<label kind="invariant" x="-85" y="-153">t &lt;= move_time</label>
		</location>
		<location id="id58" x="-161" y="59">
			<committed/>
		</location>
		<location id="id59" x="-340" y="-161">
		</location>
		<init ref="id56"/>
		<transition id="id60">
			<source ref="id55"/>
			<target ref="id59"/>
			<label kind="synchronisation" x="-501" y="-153">call_fr[x][y]?</label>
		</transition>
		<transition id="id61">
			<source ref="id58"/>
			<target ref="id55"/>
			<label kind="assignment" x="-510" y="68">available_fr += 1,
end_assist()</label>
			<nail x="-553" y="59"/>
		</transition>
		<transition id="id62">
			<source ref="id55"/>
			<target ref="id55"/>
			<label kind="select" x="-663" y="-391">ii : int[-1, 1],
jj : int[-1, 1]</label>
			<label kind="guard" x="-663" y="-348">is_move_valid(x + ii, y + jj)</label>
			<label kind="synchronisation" x="-653" y="-246">tick?</label>
			<label kind="assignment" x="-663" y="-331">move(ii, jj)</label>
			<nail x="-671" y="-297"/>
			<nail x="-552" y="-297"/>
		</transition>
		<transition id="id63">
			<source ref="id57"/>
			<target ref="id54"/>
			<label kind="guard" x="8" y="-204">t &gt;= move_time</label>
			<label kind="assignment" x="8" y="-187">t = 0</label>
		</transition>
		<transition id="id64">
			<source ref="id59"/>
			<target ref="id57"/>
			<label kind="synchronisation" x="-280" y="-238">fr_assist[x][y]?</label>
			<label kind="assignment" x="-280" y="-221">t = 0,
available_fr -= 1,
do_fr_assist()</label>
		</transition>
		<transition id="id65">
			<source ref="id54"/>
			<target ref="id58"/>
			<label kind="guard" x="-68" y="59">t &gt;= T_fr[id]</label>
			<label kind="synchronisation" x="-68" y="76">assist_success[targ_x][targ_y]!</label>
			<nail x="170" y="58"/>
		</transition>
		<transition id="id66">
			<source ref="id56"/>
			<target ref="id55"/>
			<label kind="synchronisation" x="-825" y="-161">init_done?</label>
			<label kind="assignment" x="-825" y="-144">init_state()</label>
		</transition>
	</template>
	<system>import "/home/alberton/Documents/formal-analysis-of-search-and-rescue-scenarios/visualizer/build/libvisualizer.so" {
    void send_state_via_post_request(int n_cols, int n_rows, int &amp;map[N_CELLS], bool &amp;drone_map[N_CELLS]);
};

meta int flat_map[N_CELLS];
meta bool flat_drone_map[N_CELLS];

void prepare_flat_map() {
    for (x : int[0, N_COLS-1]) {
        for (y : int[0, N_ROWS-1]) {
            // Flatten the maps
            flat_map[x*N_COLS + y] = map[x][y];
            flat_drone_map[x*N_COLS + y] = drone_map[x][y];
        }
    }
}

void send_state() {
    prepare_flat_map();
    send_state_via_post_request(N_COLS, N_ROWS, flat_map, flat_drone_map);
}

after_update { send_state() }

system Initializer, Drone, Survivor, FirstResponder;
</system>
	<queries>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
