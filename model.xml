<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>/***********************************
 Configuration Parameters
************************************/

// Grid size
const int N_COLS = 10; // x
const int N_ROWS = 10; // y

// Drone vision range
const int N_v = 2;

// Drone movement side 
const int N_r = 2;

// Assistance duration of first responders
const int T_fr = 5;
// Assistance duration of zero responders
const int T_zr = 8;

// Time after which a survivor in need dies
const int T_v = 15;


/***********************************
 Global Variables &amp; Constants
************************************/

// Map cell status enumeration
const int CELL_FIRST =          0;

const int CELL_EMPTY =          CELL_FIRST + 0;
const int CELL_FIRE =           CELL_FIRST + 1;
const int CELL_EXIT =           CELL_FIRST + 2;
const int CELL_FIRST_RESP =     CELL_FIRST + 3;
const int CELL_SURVIVOR =       CELL_FIRST + 4;
const int CELL_ZERO_RESP =      CELL_FIRST + 5;
const int CELL_IN_NEED =        CELL_FIRST + 6;
const int CELL_ASSISTED =       CELL_FIRST + 7; // Survivor in need busy being assisted
const int CELL_ASSISTING =      CELL_FIRST + 8; // First responder busy assisting

const int CELL_LAST =           CELL_ASSISTING;

// Map
int[CELL_FIRST,CELL_LAST] map[N_COLS][N_ROWS];

// Channels
chan zr_assist[N_COLS][N_ROWS];        // Channels used by drones to instruct survivors to act as zero responders and assist a survivor in need
chan call_fr[N_COLS][N_ROWS];          // Channels used by drones to instruct survivors to go call a first responder
chan fr_assist[N_COLS][N_ROWS];        // Channels used by survivors to instruct first responders to assist a survivor in need
chan assist_success[N_COLS][N_ROWS];   // Channels for signaling that an assistance was completed successfully

// The global initializion channel
urgent broadcast chan init_done;

// The number of available first responders at any given moment
// Every first responders in the system increments this value during init Every first responders in the system increments this value during init
int available_fr;


/***********************************
 Util functions
************************************/

// Returns the maximum between the two given integers
int imax(int a, int b) {
    return (a &gt;= b) ? a : b;
}

// Returns the minimum between the two given integers
int imin(int a, int b) {
    return (a &lt;= b) ? a : b;
}

// Returns the interger value clamped to the range [lower, upper]
int iclamp(int value, int lower, int upper) {
    return imax(lower, imin(value, upper));
}

// Returns the distance between two points in the grid
int distance(int x1, int y1, int x2, int y2) {
    int x_distance = x1 - x2;
    int y_distance = y1 - y2;

    if (x_distance &lt; 0)
        x_distance = -x_distance;
    if (y_distance &lt; 0)
        y_distance = -y_distance;

    return imax(x_distance, y_distance);
}
</declaration>
	<template>
		<name x="5" y="5">Initializer</name>
		<declaration>void init_assignment_example() {
    // Init the map will all empty cells
    for(x : int[0, N_ROWS-1])
        for(y : int[0, N_COLS-1])
            map[x][y] = CELL_EMPTY;

    // Set fires
    map[5][1] = CELL_FIRE;
    map[6][1] = CELL_FIRE;
    map[5][2] = CELL_FIRE;
    map[6][2] = CELL_FIRE;
    map[4][3] = CELL_FIRE;
    map[5][3] = CELL_FIRE;
    map[6][3] = CELL_FIRE;
    map[4][4] = CELL_FIRE;
    map[5][4] = CELL_FIRE;

    // Set exits
    map[0][4] = CELL_EXIT;
    map[9][4] = CELL_EXIT;
    map[0][5] = CELL_EXIT;
    map[9][5] = CELL_EXIT;
}
</declaration>
		<location id="id0" x="255" y="0">
		</location>
		<location id="id1" x="42" y="0">
			<committed/>
		</location>
		<location id="id2" x="-221" y="0">
			<committed/>
		</location>
		<init ref="id2"/>
		<transition id="id3">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="68" y="0">init_done!</label>
		</transition>
		<transition id="id4">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="assignment" x="-204" y="0">init_assignment_example()</label>
		</transition>
	</template>
	<template>
		<name>Drone</name>
		<parameter>int x, int y</parameter>
		<declaration>int move_policy_next_move_idx = 0;

const int MOVE_POLICY_LEN = N_r * 4;

void step_calculation(int &amp;next_x, int &amp;next_y) {
    if (move_policy_next_move_idx &lt; MOVE_POLICY_LEN / 4) // We have to move right
    {
        next_x += 1;
        next_y += 0;
    }
    else if (move_policy_next_move_idx &lt; 2 * MOVE_POLICY_LEN / 4) // We have to move up
    {
        next_x += 0;
        next_y += 1;
    }
    else if (move_policy_next_move_idx &lt; 3*MOVE_POLICY_LEN / 4) // We have to move left
    {
        next_x += -1;
        next_y += 0;
    }
    else if (move_policy_next_move_idx &lt; 4 * MOVE_POLICY_LEN / 4) // We have to move down
    {
        next_x += 0;
        next_y += -1;
    }
    
    move_policy_next_move_idx += 1;
    if(move_policy_next_move_idx &gt;= MOVE_POLICY_LEN)
    {
        move_policy_next_move_idx = 0;
    }
}

// Drone search bounds, updated at every move
int x_lower;
int x_upper;
int y_lower;
int y_upper;

void move_one_step() {
    // Update position
    step_calculation(x,y);

    x =  imax(x, 0); // check if we are out of the left side of the map
    x =  imin(x, N_COLS - 1); // check if we are out of the right side of the map
    y =  imax(y, 0); // check if we are out of the bottom side of the map
    y =  imin(y, N_ROWS - 1); // check if we are out of the top side of the map
    
    // Update search bounds
    x_lower = imax(x - N_v, 0);
    x_upper = imin(x + N_v, N_COLS - 1);
    y_lower = imax(y - N_v, 0);
    y_upper = imin(y + N_v, N_ROWS - 1); 
}

// Survivor, Survivor-In-Need and First-Responder detection is done in a pipelined way
// Each stage of the pipeline saves the coordinates of the detected target into variables
// that are later used to make decisions about instructions the drone will give to the survivor

// Detected Survivor position
int s_x;
int s_y;

// Detected Survivor-In-Need position
int n_x;
int n_y;

// Detected First-Responder position
int fr_x;
int fr_y;

bool is_in_need(int xx, int yy) {
    return x_lower &lt;= xx &amp;&amp; xx &lt;= x_upper &amp;&amp;
           y_lower &lt;= yy &amp;&amp; yy &lt;= y_upper &amp;&amp;
           map[xx][yy] == CELL_IN_NEED;
}

void set_in_need(int xx, int yy) {
    n_x = xx;
    n_y = yy;
}

bool is_survivor(int xx, int yy) {
    // A survivor must be in the field of view
    return x_lower &lt;= xx &amp;&amp; xx &lt;= x_upper &amp;&amp;
           y_lower &lt;= yy &amp;&amp; yy &lt;= y_upper &amp;&amp;
           map[xx][yy] == CELL_SURVIVOR;
}

void set_survivor(int xx, int yy) {
    s_x = xx;
    s_y = yy;
}

bool is_first_resp(int xx, int yy) {
    return map[xx][yy] == CELL_FIRST_RESP;
}

void set_first_resp(int xx, int yy) {
    fr_x = xx;
    fr_y = yy;
}

// Returns whether the drone is near a survivor in need and a moving survivor
// Used to control access to the decision-making locations
bool survivors_near() {
    int i, j;
    bool found_in_need = false;
    bool found_survivor = false;

    for (i = x_lower; i &lt;= x_upper; i += 1) {
        for (j = y_lower; j &lt;= y_upper; j += 1) {
            int cell = map[i][j];
            
            // Check map cell and update flags
            if (cell == CELL_IN_NEED)
                found_in_need = true;
            else if (cell == CELL_SURVIVOR)
                found_survivor = true;
            
            // Exit if we found an in_need cell and an survivor cell
            if (found_in_need &amp;&amp; found_survivor)
                return true;
        }
    }

    return false;
}

// Returns whether a first responder should be called to assist a survivor in need
bool prefer_fr(int xx, int yy, int xf, int yf) {
    // Greedy approach: prefer the minimum time to safety
    
    bool is_fr_available = available_fr &gt; 0;
    
    int dist = distance(xx, yy, xf, yf);
    
    return is_fr_available;
}

bool prefer_zr() {
    return true;
}
</declaration>
		<location id="id5" x="-170" y="-535">
			<name x="-153" y="-569">FoundFirstResp</name>
			<committed/>
		</location>
		<location id="id6" x="-425" y="-612">
			<name x="-408" y="-646">InstructZeroResp</name>
			<committed/>
		</location>
		<location id="id7" x="-170" y="-799">
			<name x="-153" y="-833">FindFirstResponder</name>
			<committed/>
		</location>
		<location id="id8" x="-424" y="-799">
			<name x="-408" y="-833">SurvivorAndInNeedSelected</name>
			<committed/>
		</location>
		<location id="id9" x="-688" y="-799">
			<name x="-671" y="-833">SurvivorSelected</name>
			<committed/>
		</location>
		<location id="id10" x="-1589" y="-799">
		</location>
		<location id="id11" x="-1402" y="-799">
			<name x="-1385" y="-833">Moving</name>
			<committed/>
		</location>
		<location id="id12" x="-1164" y="-799">
			<name x="-1147" y="-833">Scanning</name>
		</location>
		<location id="id13" x="-943" y="-799">
			<name x="-926" y="-833">FoundSurvivors</name>
			<committed/>
		</location>
		<init ref="id10"/>
		<transition id="id14">
			<source ref="id5"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-986" y="-442">call_fr[n_x][n_x]!</label>
			<label kind="assignment" x="-986" y="-425">map[n_x][n_y] = CELL_ASSISTED</label>
			<nail x="-170" y="-450"/>
			<nail x="-1402" y="-450"/>
		</transition>
		<transition id="id15">
			<source ref="id6"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-994" y="-544">zr_assist[n_x][n_y]!</label>
			<label kind="assignment" x="-994" y="-527">map[n_x][n_y] = CELL_ASSISTED</label>
			<nail x="-425" y="-544"/>
			<nail x="-1402" y="-544"/>
		</transition>
		<transition id="id16">
			<source ref="id7"/>
			<target ref="id5"/>
			<label kind="select" x="-161" y="-705">xx : int[0, N_COLS-1],
yy : int[0, N_ROWS-1]</label>
			<label kind="guard" x="-161" y="-663">is_first_resp(xx, yy)</label>
			<label kind="assignment" x="-161" y="-646">set_first_resp(xx, yy)</label>
		</transition>
		<transition id="id17">
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="guard" x="-416" y="-714">available_fr == 0</label>
		</transition>
		<transition id="id18">
			<source ref="id12"/>
			<target ref="id13"/>
			<label kind="guard" x="-1130" y="-799">survivors_near()</label>
			<nail x="-1147" y="-799"/>
		</transition>
		<transition id="id19">
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="-408" y="-799">available_fr &gt; 0</label>
			<label kind="comments" x="-408" y="-901">TODO: available_fr can
potentially be removed</label>
		</transition>
		<transition id="id20">
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="select" x="-662" y="-799">xx : int[0, N_COLS-1],
yy : int[0, N_ROWS-1]</label>
			<label kind="guard" x="-662" y="-757">is_in_need(xx, yy)</label>
			<label kind="assignment" x="-662" y="-739">set_in_need(xx, yy)</label>
			<label kind="comments" x="-671" y="-714">Finds one in_need in the
field of view and saves
its coordinates</label>
		</transition>
		<transition id="id21">
			<source ref="id13"/>
			<target ref="id9"/>
			<label kind="select" x="-917" y="-799">xx : int[0, N_COLS-1],
yy : int[0, N_ROWS-1]</label>
			<label kind="guard" x="-917" y="-756">is_survivor(xx, yy)</label>
			<label kind="assignment" x="-917" y="-739">set_survivor(xx, yy)</label>
			<label kind="comments" x="-926" y="-714">Finds one survivor in the
field of view and saves
its coordinates</label>
		</transition>
		<transition id="id22">
			<source ref="id12"/>
			<target ref="id11"/>
			<label kind="guard" x="-1351" y="-918">!survivors_near()</label>
			<nail x="-1164" y="-892"/>
			<nail x="-1402" y="-892"/>
		</transition>
		<transition id="id23">
			<source ref="id11"/>
			<target ref="id12"/>
			<label kind="assignment" x="-1351" y="-799">move_one_step()</label>
		</transition>
		<transition id="id24">
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-1564" y="-799">init_done?</label>
		</transition>
	</template>
	<template>
		<name>FirstResponder</name>
		<parameter>int x, int y</parameter>
		<declaration>clock t;

// Distance variable used to emulate the time taken for this survivor to perform grid movements
int move_time = 0;

// Target coordinates that this survivor should move to
int targ_x;
int targ_y;

void do_fr_assist(int xx, int yy) {
    // Set moving time
    move_time = distance(x, y, xx, yy);
    
    // Set assisted coords notify the end of the assistance later
    targ_x = xx;
    targ_y = yy;
    
    // Set our cell as busy first responder
    map[x][y] = CELL_ASSISTING;
}

void end_assist() {
    // Set our previous position as empty
    map[x][y] = CELL_EMPTY;

    // Teleport to the position of the survivor-in-need we just finished assisting
    x = targ_x;
    y = targ_y;
    
    // Set ourselves at the new position
    map[x][y] = CELL_FIRST_RESP;
}
</declaration>
		<location id="id25" x="170" y="-161">
			<name x="143" y="-203">Assisting</name>
		</location>
		<location id="id26" x="-552" y="-161">
			<name x="-586" y="-203">Available</name>
		</location>
		<location id="id27" x="-850" y="-161">
		</location>
		<location id="id28" x="-195" y="-161">
			<name x="-220" y="-203">Moving</name>
		</location>
		<init ref="id27"/>
		<transition id="id29">
			<source ref="id28"/>
			<target ref="id25"/>
			<label kind="guard" x="-144" y="-161">t &gt;= move_time</label>
			<label kind="assignment" x="-144" y="-144">t = 0</label>
		</transition>
		<transition id="id30">
			<source ref="id26"/>
			<target ref="id28"/>
			<label kind="select" x="-510" y="-161">xx : int[0, N_COLS-1],
yy : int[0, N_ROWS-1]</label>
			<label kind="synchronisation" x="-510" y="-118">fr_assist[xx][yy]?</label>
			<label kind="assignment" x="-510" y="-101">t = 0,
available_fr -= 1,
do_fr_assist(xx, yy)</label>
		</transition>
		<transition id="id31">
			<source ref="id25"/>
			<target ref="id26"/>
			<label kind="guard" x="-297" y="59">t &gt;= T_fr</label>
			<label kind="synchronisation" x="-297" y="76">assist_success[targ_x][targ_y]!</label>
			<label kind="assignment" x="-297" y="94">available_fr += 1,
end_assist()</label>
			<nail x="170" y="58"/>
			<nail x="-552" y="59"/>
		</transition>
		<transition id="id32">
			<source ref="id27"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-825" y="-161">init_done?</label>
			<label kind="assignment" x="-825" y="-144">map[x][y] = CELL_FIRST_RESP,
available_fr += 1</label>
		</transition>
	</template>
	<template>
		<name>Survivor</name>
		<parameter>int x, int y</parameter>
		<declaration>clock t;

// Distance from fire when this survivor becomes in need
const int FIRE_RADIUS = 1;

// Distance from exit when this survivor becomes in safe
const int EXIT_RADIUS = 1;

// Distance variable used to emulate the time taken for this survivor to perform grid movements
int move_time = 0;

// Target coordinates that this survivor should move to
int targ_x;
int targ_y;

void do_zr_assist(int xx, int yy) {
    // Set moving time
    move_time = distance(x, y, xx, yy);
    
    // Set assisted coords notify the end of the assistance later
    targ_x = xx;
    targ_y = yy;
    
    // Set our cell as zero responder
    map[x][y] = CELL_ZERO_RESP;
}

void do_call_fr(int xx, int yy) {
    // Set moving time
    move_time = distance(x, y, xx, yy);
    
    // Set coords of the first responder to signal it once reached
    targ_x = xx;
    targ_y = yy;
    
    // Set our cell as zero responder
    map[x][y] = CELL_ZERO_RESP;
}

bool is_fire_near(int xx, int yy) {
    int x_lower = imax(xx - FIRE_RADIUS, 0);
    int x_upper = imin(xx + FIRE_RADIUS, N_COLS - 1);
    int y_lower = imax(yy - FIRE_RADIUS, 0);
    int y_upper = imin(yy + FIRE_RADIUS, N_ROWS - 1);

    int i, j;
    for (i = x_lower; i &lt;= x_upper; i += 1)
        for (j = y_lower; j &lt;= y_upper; j += 1)
            if (map[i][j] == CELL_FIRE)
                return true;

    return false;
}

bool is_exit_near(int xx, int yy) {
    int x_lower = imax(xx - EXIT_RADIUS, 0);
    int x_upper = imin(xx + EXIT_RADIUS, N_COLS - 1);
    int y_lower = imax(yy - EXIT_RADIUS, 0);
    int y_upper = imin(yy + EXIT_RADIUS, N_ROWS - 1);

    int i, j;
    for (i = x_lower; i &lt;= x_upper; i += 1)
        for (j = y_lower; j &lt;= y_upper; j += 1)
            if (map[i][j] == CELL_EXIT)
                return true;

    return false;
}


void find_nearest_exit(int &amp;xx, int &amp;yy) {
    int exitDistance = imax(N_ROWS, N_COLS) + 1; // max value
    int i, j;

    for (i = 0; i &lt; N_COLS; i += 1) {
        for (j = 0; j &lt; N_ROWS; j += 1) {
            int cell = map[i][j];
            
            if (cell == CELL_EXIT) {
                int disTemp = distance(x, y, i, j);
                if (disTemp &lt;= exitDistance) {
                    xx = i;
                    yy = j;
                    exitDistance = disTemp;
                }
            }
        }
    }
}

bool is_move_valid(int xx, int yy) {
    bool valid;

    // At least one coordinate must change, the move cannot target the same position
    valid = xx != x || yy != y;

    // We cannot move near a fire
    valid &amp;= !is_fire_near(xx, yy);

    // We can move only towards empty cells
    valid &amp;= map[xx][yy] == CELL_EMPTY;

    // We can only move inside the map
    valid &amp;= 0 &lt;= xx &amp;&amp; xx &lt;= N_COLS - 1 &amp;&amp; 0 &lt;= yy &amp;&amp; yy &lt;= N_ROWS - 1;

    return valid;
}

int exit_x, exit_y; // the current exit we are trying to reach

/**
 * This moving policy tries to follow a direct path to the nearest exit.
 * When the next move on the direct path cannot be taken (the cell is
 * occupied or there is a fire near) we randomly choose a valid move.
 */
void move(int ii, int jj) {
    int next_x, next_y;
    int direction_x, direction_y;
    
    // Random function to prefer X half of the time 
    bool prefer_x = (ii * jj) != 0;

    find_nearest_exit(exit_x, exit_y);

    // Tells what direction to move to over x to go towards the exit
    if (exit_x - x &gt; 0)
        direction_x = 1; // Right
    else if (exit_x - x &lt; 0) 
        direction_x = -1; // Left
    else
        direction_x = 0; // Stay put

    // Same thing for y
    if (exit_y - y &gt; 0)
        direction_y = 1; // Down
    else if (exit_y - y &lt; 0) 
        direction_y = -1; // Up
    else
        direction_y = 0; // Stay put

    // Compute the next optimal position towards the nearest exit
    next_x = x + direction_x;
    next_y = y + direction_y;

    // Set the current position empty because we'll move
    map[x][y] = CELL_EMPTY;

    if (is_move_valid(next_x, next_y)) {
        // We move to the optimal cell if the move is valid
        x = next_x;
        y = next_y;
    } else if (prefer_x) {
        // If we prefer X, try in order X -&gt; Y -&gt; random 
        if (direction_x != 0 &amp;&amp; !is_fire_near(next_x, y)) {
            // The optimal X direction is not null and is feasible
            x = next_x;
            y = y;
        } else if (direction_y != 0 &amp;&amp; !is_fire_near(x, next_y)) {
            // The optimal Y direction is not null and is feasible
            x = x;
            y = next_y;
        } else {
            // Move in a random direction from the chosen transition
            x += ii;
            y += jj;
        }
    } else if (!prefer_x) {
        // If we prefer Y, try in order Y -&gt; X -&gt; random
        if (direction_y != 0 &amp;&amp; !is_fire_near(x, next_y)) {
            // The optimal Y direction is not null and is feasible
            x = x;
            y = next_y;
        } else if (direction_x != 0 &amp;&amp; !is_fire_near(next_x, y)) {
            // The optimal X direction is not null and is feasible
            x = next_x;
            y = y;
        } else {
            // Move in a random direction from the chosen transition
            x += ii;
            y += jj;
        }
    }

    map[x][y] = CELL_SURVIVOR;
}
</declaration>
		<location id="id33" x="-76" y="195">
			<name x="-51" y="187">Moving</name>
		</location>
		<location id="id34" x="314" y="84">
			<name x="229" y="101">ActingZeroResponder</name>
		</location>
		<location id="id35" x="-382" y="85">
			<committed/>
		</location>
		<location id="id36" x="-136" y="-255">
			<name x="-161" y="-314">InNeed</name>
			<label kind="invariant" x="-161" y="-297">t &lt;= T_v</label>
		</location>
		<location id="id37" x="-637" y="85">
		</location>
		<location id="id38" x="170" y="-145">
			<name x="153" y="-187">Dead</name>
		</location>
		<location id="id39" x="773" y="84">
			<name x="797" y="75">Safe</name>
		</location>
		<location id="id40" x="331" y="296">
			<name x="246" y="262">CallingFirstResponder</name>
		</location>
		<location id="id41" x="-382" y="459">
			<name x="-458" y="442">AmISafe</name>
			<committed/>
		</location>
		<init ref="id37"/>
		<transition id="id42">
			<source ref="id41"/>
			<target ref="id35"/>
			<label kind="guard" x="-629" y="255">!is_exit_near(x,y)</label>
		</transition>
		<transition id="id43">
			<source ref="id41"/>
			<target ref="id39"/>
			<label kind="guard" x="170" y="467">is_exit_near(x,y)</label>
			<label kind="assignment" x="153" y="484">map[x][y] = CELL_EMPTY</label>
			<nail x="773" y="459"/>
		</transition>
		<transition id="id44">
			<source ref="id38"/>
			<target ref="id38"/>
			<label kind="synchronisation" x="255" y="-144">assist_success[x][y]?</label>
			<label kind="comments" x="255" y="-188">Consume signals to avoid deadlocking
the first/zero responder</label>
			<nail x="238" y="-171"/>
			<nail x="238" y="-120"/>
		</transition>
		<transition id="id45">
			<source ref="id36"/>
			<target ref="id39"/>
			<label kind="synchronisation" x="34" y="-297">assist_success[x][y]?</label>
			<label kind="assignment" x="34" y="-281">map[x][y] = CELL_EMPTY</label>
			<nail x="773" y="-256"/>
		</transition>
		<transition id="id46">
			<source ref="id40"/>
			<target ref="id39"/>
			<label kind="guard" x="425" y="305">t &gt;= move_time</label>
			<label kind="synchronisation" x="425" y="322">fr_assist[targ_x][targ_y]!</label>
			<label kind="assignment" x="425" y="340">map[x][y] = CELL_EMPTY</label>
			<nail x="773" y="296"/>
		</transition>
		<transition id="id47">
			<source ref="id33"/>
			<target ref="id40"/>
			<label kind="select" x="68" y="306">xx : int[0, N_COLS-1],
yy : int[0, N_ROWS-1]</label>
			<label kind="synchronisation" x="68" y="348">call_fr[xx][yy]?</label>
			<label kind="assignment" x="68" y="366">do_call_fr(xx, yy)</label>
			<nail x="8" y="296"/>
		</transition>
		<transition id="id48">
			<source ref="id36"/>
			<target ref="id38"/>
			<label kind="guard" x="-110" y="-187">t &gt;= T_v</label>
			<label kind="assignment" x="-110" y="-170">map[x][y] = CELL_EMPTY</label>
			<nail x="-136" y="-144"/>
		</transition>
		<transition id="id49">
			<source ref="id34"/>
			<target ref="id39"/>
			<label kind="guard" x="391" y="25">t &gt;= T_zr + move_time</label>
			<label kind="synchronisation" x="391" y="42">assist_success[targ_x][targ_y]!</label>
			<label kind="assignment" x="391" y="59">map[x][y] = CELL_EMPTY</label>
		</transition>
		<transition id="id50">
			<source ref="id33"/>
			<target ref="id41"/>
			<label kind="select" x="-221" y="314">ii : int[-1, 1],
jj : int[-1, 1]</label>
			<label kind="guard" x="-221" y="357">is_move_valid(x + ii, y + jj)</label>
			<label kind="assignment" x="-221" y="374">move(ii,jj)</label>
		</transition>
		<transition id="id51">
			<source ref="id35"/>
			<target ref="id33"/>
			<label kind="guard" x="-297" y="85">!is_fire_near(x,y)</label>
		</transition>
		<transition id="id52">
			<source ref="id37"/>
			<target ref="id35"/>
			<label kind="synchronisation" x="-611" y="17">init_done?</label>
			<label kind="assignment" x="-611" y="34">map[x][y] = CELL_SURVIVOR</label>
		</transition>
		<transition id="id53">
			<source ref="id35"/>
			<target ref="id36"/>
			<label kind="guard" x="-467" y="-170">is_fire_near(x,y)</label>
			<label kind="assignment" x="-467" y="-153">map[x][y] = CELL_IN_NEED,
t = 0</label>
		</transition>
		<transition id="id54">
			<source ref="id33"/>
			<target ref="id34"/>
			<label kind="select" x="59" y="0">xx : int[0, N_COLS-1],
yy : int[0, N_ROWS-1]</label>
			<label kind="synchronisation" x="59" y="42">zr_assist[xx][yy]?</label>
			<label kind="assignment" x="59" y="59">do_zr_assist(xx, yy)</label>
			<label kind="comments" x="85" y="161">Synchronize with the drone non-deterministically
xx and yy are the target coords</label>
			<nail x="8" y="84"/>
		</transition>
	</template>
	<system>initializer = Initializer();

drone_1 = Drone(3, 1);
survivor_1 = Survivor(2, 1); // Survivor
survivor_2 = Survivor(4, 2); // In need
survivor_3 = Survivor(5, 8); // Survivor
first_responder_1 = FirstResponder(2, 3);
first_responder_2 = FirstResponder(2, 4);

system initializer, survivor_1, drone_1, survivor_2, survivor_3;//, first_responder_1, first_responder_2;
</system>
	<queries>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
