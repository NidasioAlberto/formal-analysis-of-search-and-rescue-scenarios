<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>/******************************************************************************
 *                                  Types                                     *
 ******************************************************************************/

typedef struct {
    int x;
    int y;
} pos_t;

/******************************************************************************
 *                          Configuration Parameters                          *
 ******************************************************************************/

// Map size
const int N_COLS = 10; // x
const int N_ROWS = 10; // y

// Number of total cells, used when flatten out the map for the visualizer
const int N_CELLS = N_COLS * N_ROWS;

// Scenario found in the project documentation

// Number of drones and their starting positions
const int N_DRONES = 2;
typedef int[0, N_DRONES-1] drone_id_t;
const pos_t drones_starting_pos[N_DRONES] = {{3, 1}, {6, 6}};
const int N_v[N_DRONES] = {1, 2}; // Drones vision range
const int N_r[N_DRONES] = {2, 2}; // Drones movement

// Number of survivors and their starting positions
const int N_SURVIVORS = 3;
typedef int[0, N_SURVIVORS-1] survivor_id_t;
const pos_t survivors_starting_pos[N_SURVIVORS] = {{2, 1}, {4, 2}, {5, 8}};
const int T_zr[N_SURVIVORS] = {8, 8, 8}; // Zero reponders assistance duration
const int T_v[N_SURVIVORS] = {15, 15, 15}; // Time after which a survivor in need dies

// Number of first responders and their starting positions
const int N_FIRST_RESPONDERS = 2;
typedef int[0, N_FIRST_RESPONDERS-1] first_resp_id_t;
const pos_t first_responders_starting_pos[N_FIRST_RESPONDERS] = {{2, 3}, {8, 5}};
const int T_fr[N_FIRST_RESPONDERS] = {5, 5}; // First reponders assistance duration

// Super simple scenario

/*
// Number of drones and their starting positions
const int N_DRONES = 1;
typedef int[0, N_DRONES-1] drone_id_t;
const pos_t drones_starting_pos[N_DRONES] = {{3, 1}};
const int N_v[N_DRONES] = {1}; // Drones vision range
const int N_r[N_DRONES] = {2}; // Drones movement side

// Number of survivors and their starting positions
const int N_SURVIVORS = 2;
typedef int[0, N_SURVIVORS-1] survivor_id_t;
const pos_t survivors_starting_pos[N_SURVIVORS] = {{2, 1}, {4, 2}};
const int T_zr[N_SURVIVORS] = {8, 8}; // Zero reponders assistance duration
const int T_v[N_SURVIVORS] = {15, 15}; // Time after which a survivor in need dies

// Number of first responders and their starting positions
const int N_FIRST_RESPONDERS = 1;
typedef int[0, N_FIRST_RESPONDERS-1] first_resp_id_t;
const pos_t first_responders_starting_pos[N_FIRST_RESPONDERS] = {{2, 3}};
const int T_fr[N_FIRST_RESPONDERS] = {5}; // First reponders assistance duration
*/

/******************************************************************************
 *                                 Constants                                  *
 ******************************************************************************/

// Map cell status enumeration
const int CELL_FIRST =      0;

const int CELL_EMPTY =      CELL_FIRST + 0;
const int CELL_FIRE =       CELL_FIRST + 1;
const int CELL_EXIT =       CELL_FIRST + 2;
const int CELL_FIRST_RESP = CELL_FIRST + 3;
const int CELL_SURVIVOR =   CELL_FIRST + 4;
const int CELL_ZERO_RESP =  CELL_FIRST + 5;
const int CELL_IN_NEED =    CELL_FIRST + 6;
const int CELL_ASSISTED =   CELL_FIRST + 7; // Survivor that is being assisted (by either zero or first responders)
const int CELL_ASSISTING =  CELL_FIRST + 8; // First responder busy assisting a survivor

const int CELL_LAST =           CELL_ASSISTING;

/******************************************************************************
 *                              Global variables                              *
 ******************************************************************************/

// Maps
int[CELL_FIRST, CELL_LAST] map[N_COLS][N_ROWS];
bool drone_map[N_COLS][N_ROWS];

// Channels
broadcast chan init_done;                       // Global initializing channel
chan await_job[N_COLS][N_ROWS];                 // Used by drones to instruct survivors to wait for a job (how to act will be notified later)
chan assist_directly[N_COLS][N_ROWS];           // Used by drones to instruct survivors to assist directly an in_need
chan go_call_a_fr[N_COLS][N_ROWS];              // Used by drones to instruct survivors to go call a first responder
chan lock_fr[N_COLS][N_ROWS];                   // Used by survivors to lock a first_responder from moving
chan arrived[N_COLS][N_ROWS];                   // Used by survivors to notify that they reached the target first_responder
chan starting_assistance[N_COLS][N_ROWS];       // Used by zero_responders and first_responders to notify an in_need that the assistance procedure has started
chan fr_assist[N_COLS][N_ROWS];                 // Used by survivors to instruct first responders to assist a survivor in need
broadcast chan assist_complete[N_COLS][N_ROWS]; // For signaling that an assistance was completed successfully

// Meta variables used to share target positions
/*meta*/ pos_t target_in_need;
/*meta*/ pos_t target_first_resp;

// Number of available first responders at any given moment
// Every first responder in the system increments this value during init
int available_fr;

/******************************************************************************a
 *                             Utility functions                              *
 ******************************************************************************/

void set_target_in_need(int x, int y) {
    target_in_need.x = x;
    target_in_need.y = y;
}

void set_target_first_resp(int x, int y) {
    target_first_resp.x = x;
    target_first_resp.y = y;
}

void set_map(pos_t pos, int val) {
    map[pos.x][pos.y] = val;
}

int get_map(pos_t pos) {
    return map[pos.x][pos.y];
}

void set_drone_map(pos_t pos, bool val) {
    drone_map[pos.x][pos.y] = val;
}

// Returns the interger value clamped to the range [lower, upper]
int iclamp(int value, int lower, int upper) {
    return lower &gt;? (value &lt;? upper);
}

// Returns the distance between two points in the grid
int distance(pos_t pos1, pos_t pos2) {
    int x_distance = abs(pos1.x - pos2.x);
    int y_distance = abs(pos1.y - pos2.y);
    return x_distance &gt;? y_distance;
}

// Checks if a position is inside of the map
bool is_pos_in_map(pos_t pos) {
    return pos.x &gt;= 0 &amp;&amp; pos.x &lt; N_COLS &amp;&amp; pos.y &gt;= 0 &amp;&amp; pos.y &lt; N_ROWS;
}

// Checks if a position is inside the given bounds (included) and inside the map 
bool is_pos_in_bound(pos_t pos, pos_t lower_bound, pos_t upper_bound) {
    return pos.x &gt;= lower_bound.x &amp;&amp; pos.x &lt;= upper_bound.x &amp;&amp; pos.y &gt;= lower_bound.y &amp;&amp; pos.y &lt;= upper_bound.y;
}

// Checks if a position is in a radius (included) from a given position and inside the map
bool is_pos_in_radius(pos_t pos, pos_t center, int radius) {
    pos_t lower_bound = {center.x - radius, center.y - radius};
    pos_t upper_bound = {center.x + radius, center.y + radius};

    return is_pos_in_bound(pos, lower_bound, upper_bound);
}

// Check if a location on the map has the given value
bool map_check_val(pos_t pos, int value) {
    // Coordinates must be inside the map
    if (!is_pos_in_map(pos))
        return false;

    return map[pos.x][pos.y] == value;
}

// Check if a location on the map in the given bounds (included) has the provided value
bool map_check_val_with_bounds(pos_t pos, int value, pos_t lower_bound, pos_t upper_bound) {
    // Check provided bounds
    if (!is_pos_in_bound(pos, lower_bound, upper_bound))
        return false;

    return map_check_val(pos, value);
}

// Check if a location on the map in a radius (included) from a position has the provided value
bool map_check_val_with_radius_bound(pos_t pos, int value, pos_t center, int radius) {
    // Check provided bounds
    if (!is_pos_in_radius(pos, center, radius))
        return false;

    return map_check_val(pos, value);
}

// Checks if the given map value is somewhere in the radius (included)
bool is_val_in_radius(pos_t pos, int value, const int radius) {
    int i, j;
    for (i = -radius; i &lt;= radius; i += 1) {
        for (j = -radius; j &lt;= radius; j += 1) {
            pos_t pos_to_check = pos;
            pos_to_check.x += i;
            pos_to_check.y += j;

            if (map_check_val(pos_to_check, value))
                return true;
        }
    }

    return false;
}

// Find the nearest value in the map starting from the given position
pos_t map_find_nearest_val(pos_t pos, int value) {
    // Initialize with maximum possible distance
    int min_dist = N_ROWS &gt;? N_COLS + 1;
    pos_t nearest_pos;

    for (x : int[0, N_COLS-1]) {
        for (y : int[0, N_ROWS-1]) {
            pos_t tmp_pos = {x, y};
            if (map_check_val(tmp_pos, value)) {
                int tmp_dist = distance(pos, tmp_pos);
                if (tmp_dist &lt;= min_dist) {
                    nearest_pos = tmp_pos;
                    min_dist = tmp_dist;
                }
            }
        }
    }
    
    return nearest_pos;
}
</declaration>
	<template>
		<name>Initializer</name>
		<declaration>void init_assignment_example() {
    // Init the map will all empty cells
    for(x : int[0, N_ROWS-1])
        for(y : int[0, N_COLS-1]) {
            map[x][y] = CELL_EMPTY;
            drone_map[x][y] = false;
        }

    // Set fires
    map[5][1] = CELL_FIRE;
    map[6][1] = CELL_FIRE;
    map[5][2] = CELL_FIRE;
    map[6][2] = CELL_FIRE;
    map[4][3] = CELL_FIRE;
    map[5][3] = CELL_FIRE;
    map[6][3] = CELL_FIRE;
    map[4][4] = CELL_FIRE;
    map[5][4] = CELL_FIRE;

    // Set exits
    map[0][4] = CELL_EXIT;
    map[9][4] = CELL_EXIT;
    map[0][5] = CELL_EXIT;
    map[9][5] = CELL_EXIT;
}
</declaration>
		<location id="id0" x="213" y="0">
		</location>
		<location id="id1" x="42" y="0">
			<committed/>
		</location>
		<location id="id2" x="-221" y="0">
			<committed/>
		</location>
		<init ref="id2"/>
		<transition id="id3">
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="59" y="0">init_done!</label>
		</transition>
		<transition id="id4">
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="assignment" x="-204" y="0">init_assignment_example()</label>
		</transition>
	</template>
	<template>
		<name>Drone</name>
		<parameter>const drone_id_t id</parameter>
		<declaration>/******************************************************************************
 *                                  Variables                                 *
 ******************************************************************************/

clock t = 0;
pos_t pos;

pos_t zr; // Selected zero_responder
pos_t in; // Selected in_need
pos_t fr; // Selected first_responder

int nv;

/******************************************************************************
 *                                Moving policy                               *
 ******************************************************************************/

// Moving policy, this includes the N_r parameter

int move_policy_next_move_idx = 0;
const int MOVE_POLICY_LEN = N_r[id] * 4;

pos_t next_step() {
    if (move_policy_next_move_idx &lt; MOVE_POLICY_LEN / 4) { // We have to move right
        pos.x += 1;
        pos.y += 0;
    }
    else if (move_policy_next_move_idx &lt; 2 * MOVE_POLICY_LEN / 4) { // We have to move up
        pos.x += 0;
        pos.y += 1;
    }
    else if (move_policy_next_move_idx &lt; 3*MOVE_POLICY_LEN / 4) { // We have to move left
        pos.x += -1;
        pos.y += 0;
    }
    else if (move_policy_next_move_idx &lt; 4 * MOVE_POLICY_LEN / 4) { // We have to move down
        pos.x += 0;
        pos.y += -1;
    }

    // Increment/wrap up index
    move_policy_next_move_idx += 1;
    if(move_policy_next_move_idx &gt;= MOVE_POLICY_LEN)
        move_policy_next_move_idx = 0;

    return pos;
}

void move() {
    // Apply movement
    set_drone_map(pos, false);
    pos = next_step();
    set_drone_map(pos, true);
}

/******************************************************************************
 *                               Other functions                              *
 ******************************************************************************/

// Tells whether the given coordinates points to a survivor that can be a zero responder (in the fov)
bool is_possible_zero_responder(int x, int y) {
    pos_t pos_to_check = {x, y};
    return map_check_val_with_radius_bound(pos_to_check, CELL_SURVIVOR, pos, N_v[id]);
}

// Check if the given coordinates points to a survivor in_need (in the fov)
bool is_in_need(int x, int y) {
    pos_t pos_to_check = {x, y};
    return map_check_val_with_radius_bound(pos_to_check, CELL_IN_NEED, pos, N_v[id]);
}

// Tells whether the drone has a survivor in its fov
bool in_need_near() {
    return is_val_in_radius(pos, CELL_IN_NEED, N_v[id]);
}

// Check if the given coordinates points to a first_responder
bool is_first_resp(int x, int y) {
    pos_t pos_to_check = {x, y};
    return map_check_val(pos_to_check, CELL_FIRST_RESP);
}

// Sets the given coordinates as the selected zero_responder
void save_zero_resp(int x, int y) {
    zr.x = x;
    zr.y = y;
}

// Sets the given coordinates as the selected in_need
void save_in_need(int x, int y) {
    in.x = x;
    in.y = y;
}

// Sets the given coordinates as the selected first_responder
void save_first_resp(int x, int y) {
    fr.x = x;
    fr.y = y;
}
</declaration>
		<location id="id5" x="-1232" y="-450">
			<name x="-1215" y="-484">FirstResponderFound</name>
			<committed/>
		</location>
		<location id="id6" x="-944" y="-561">
			<name x="-927" y="-595">AssistingDirectly</name>
			<committed/>
		</location>
		<location id="id7" x="-943" y="-450">
			<name x="-926" y="-484">SearchingFirstResponder</name>
			<committed/>
		</location>
		<location id="id8" x="-680" y="-510">
			<name x="-909" y="-518">SurvivorAndInNeedSelected</name>
			<label kind="comments" x="-918" y="-416">If there is a first responder
available, instruct the selected
zero reponder to call him,
otherwise assit directly</label>
			<committed/>
		</location>
		<location id="id9" x="-952" y="-799">
			<name x="-935" y="-833">SurvivorSelected</name>
			<committed/>
		</location>
		<location id="id10" x="-1700" y="-799" color="#ffffff">
			<name x="-1683" y="-833">Init</name>
		</location>
		<location id="id11" x="-1402" y="-799" color="#ffa500">
			<name x="-1385" y="-850">Moving</name>
			<label kind="invariant" x="-1385" y="-833">t &lt;= 1</label>
		</location>
		<init ref="id10"/>
		<transition id="id12">
			<source ref="id11"/>
			<target ref="id11"/>
			<label kind="guard" x="-1470" y="-909">t &gt;= 1</label>
			<label kind="assignment" x="-1470" y="-892">move(),
t = 0</label>
			<label kind="comments" x="-1385" y="-901">This edge is the only one that resets the clock.
This way the drone must make one move per time unit</label>
			<nail x="-1445" y="-841"/>
			<nail x="-1402" y="-858"/>
		</transition>
		<transition id="id13">
			<source ref="id5"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-1462" y="-442">go_call_a_fr[zr.x][zr.y]!</label>
			<label kind="assignment" x="-1462" y="-425">target_first_resp = fr,
target_in_need = in</label>
			<nail x="-1428" y="-450"/>
			<nail x="-1428" y="-773"/>
		</transition>
		<transition id="id14">
			<source ref="id6"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-1215" y="-552">assist_directly[zr.x][zr.y]!</label>
			<label kind="assignment" x="-1215" y="-535">target_in_need = in</label>
			<nail x="-1402" y="-561"/>
		</transition>
		<transition id="id15">
			<source ref="id7"/>
			<target ref="id5"/>
			<label kind="select" x="-1207" y="-441">x : int[0, N_COLS-1],
y : int[0, N_ROWS-1]</label>
			<label kind="guard" x="-1207" y="-399">is_first_resp(x, y)</label>
			<label kind="assignment" x="-1207" y="-382">save_first_resp(x, y)</label>
			<label kind="comments" x="-1207" y="-348">Selects one first_reponder
for the zero_responder to call</label>
		</transition>
		<transition id="id16">
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="guard" x="-918" y="-552">available_fr == 0</label>
			<nail x="-731" y="-561"/>
		</transition>
		<transition id="id17">
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="-918" y="-442">available_fr &gt; 0</label>
			<nail x="-731" y="-450"/>
		</transition>
		<transition id="id18">
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="select" x="-935" y="-791">x : int[0, N_COLS-1],
y : int[0, N_ROWS-1]</label>
			<label kind="guard" x="-935" y="-749">is_in_need(x, y)</label>
			<label kind="assignment" x="-935" y="-731">save_in_need(x, y)</label>
			<label kind="comments" x="-935" y="-697">Finds one in_need in the
field of view and saves
its coordinates</label>
			<nail x="-679" y="-799"/>
		</transition>
		<transition id="id19">
			<source ref="id11"/>
			<target ref="id9"/>
			<label kind="select" x="-1385" y="-790">x : int[0, N_COLS-1],
y : int[0, N_ROWS-1]</label>
			<label kind="guard" x="-1385" y="-747">t &gt;= 1 &amp;&amp;
in_need_near() &amp;&amp;
is_possible_zero_responder(x, y)</label>
			<label kind="synchronisation" x="-1385" y="-688">await_job[x][y]!</label>
			<label kind="assignment" x="-1385" y="-671">save_zero_resp(x, y)</label>
			<label kind="comments" x="-1385" y="-637">Finds one possible zero_responder in
the field of view, saves its coordinates
and tells him to assist</label>
		</transition>
		<transition id="id20">
			<source ref="id10"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-1683" y="-790">init_done?</label>
			<label kind="assignment" x="-1683" y="-773">pos = drones_starting_pos[id],
set_drone_map(pos, true),
nv = N_v[id]</label>
		</transition>
	</template>
	<template>
		<name>Survivor</name>
		<parameter>const survivor_id_t id</parameter>
		<declaration>/******************************************************************************
 *                                  Variables                                 *
 ******************************************************************************/

clock t = 0;
pos_t pos;

pos_t target;
pos_t fr;
pos_t in;

// Some constant that are not parameters but are still usefull to abstract
const int FIRE_RADIUS = 1; // Distance from fire when this survivor becomes in need
const int EXIT_RADIUS = 1; // Distance from exit when this survivor becomes in safe

/******************************************************************************
 *                               Other functions                              *
 ******************************************************************************/

pos_t find_nearest_exit() {
    pos_t best_exit;
    int min_distance = N_COLS + N_ROWS; // Just a big number

    for (x : int[0, N_COLS - 1]) {
        for (y : int[0, N_ROWS - 1]) {
            // Search only on the boundaries
            if(x == 0 || x == N_COLS - 1 || y == 0 || y == N_ROWS - 1) {
                pos_t curr_exit = {x, y};
                if (map_check_val(curr_exit, CELL_EXIT)) {
                    int distance = distance(pos, curr_exit);
                    if (distance &lt; min_distance) {
                        min_distance = distance;
                        best_exit = curr_exit;
                    }
                }
            }
        }
    }
    
    return best_exit;
}

// Check if the given position can be occupied by a survivor
bool is_pos_feasible(pos_t target) {
    // We can only move inside the map and we canot stay in the same position
    if (is_pos_in_map(target) &amp;&amp; target != pos) {

        // We cannot move near a fire
        bool valid = !is_val_in_radius(target, CELL_FIRE, FIRE_RADIUS);

        // We can move only towards empty cells
        valid &amp;= map_check_val(target, CELL_EMPTY);
        
        return valid;
    }

    return false;
}

int compute_best_move_distance(pos_t target) {
    int min_distance = N_COLS + N_ROWS; // Just a big number

    for (i : int[-1, 1]) {
        for (j : int[-1, 1]) {
            pos_t move = {pos.x + i, pos.y + j};
            if (is_pos_feasible(move)) {
                int distance = distance(move, target);
                if (distance &lt; min_distance)
                    min_distance = distance;
            }
        }
    }
    
    return min_distance;
}

/******************************************************************************
 *                                Moving policy                               *
 ******************************************************************************/

// The current moving policy allows only the best possible moves (the ones that minize the distance to the target)

bool is_move_valid(int i, int j) {
    pos_t next_pos = {pos.x + i, pos.y + j};
    pos_t target = find_nearest_exit();

    // Find the distance of the best move
    int min_distance = compute_best_move_distance(target);

    // A move to be valid must be feasible and must have minimum distance among the possible moves
    return is_pos_feasible(next_pos) &amp;&amp; distance(next_pos, target) == min_distance;
}

void move(int i, int j) {
    // Apply movement
    set_map(pos, CELL_EMPTY);
    pos.x += i;
    pos.y += j;
    set_map(pos, CELL_SURVIVOR);
}

/******************************************************************************
 *                               Other functions                              *
 ******************************************************************************/

bool starting_near_a_fire() {
    return is_val_in_radius(survivors_starting_pos[id], CELL_FIRE, FIRE_RADIUS);
}

bool is_fire_near() {
    return is_val_in_radius(pos, CELL_FIRE, FIRE_RADIUS);
}

bool is_exit_near() {
    return is_val_in_radius(pos, CELL_EXIT, EXIT_RADIUS);
}
</declaration>
		<location id="id21" x="153" y="-170" color="#ffa500">
			<name x="170" y="-162">Moving</name>
			<label kind="invariant" x="170" y="-145">t &lt;= 1</label>
		</location>
		<location id="id22" x="704" y="144" color="#ffc0cb">
			<name x="721" y="110">AssistingDirectly</name>
		</location>
		<location id="id23" x="858" y="-323" color="#ff0000">
			<name x="875" y="-374">InNeed</name>
			<label kind="invariant" x="875" y="-357">t &lt;= T_v[id]</label>
		</location>
		<location id="id24" x="493" y="-170" color="#ffffff">
			<name x="484" y="-153">Init</name>
		</location>
		<location id="id25" x="1164" y="-323" color="#000000">
			<name x="1113" y="-357">Dead</name>
		</location>
		<location id="id26" x="833" y="-17" color="#00ff00">
			<name x="857" y="-26">Safe</name>
		</location>
		<location id="id27" x="93" y="-17" color="#00ffff">
			<name x="110" y="-51">LockingFirstResponder</name>
			<committed/>
		</location>
		<location id="id28" x="552" y="-17" color="#ffc0cb">
			<name x="561" y="-51">WaitingCompletion</name>
		</location>
		<location id="id29" x="314" y="-18" color="#00ffff">
			<name x="323" y="-68">CallingFirstResponder</name>
			<label kind="invariant" x="323" y="-51">t &lt;= distance(pos, fr)</label>
		</location>
		<location id="id30" x="93" y="144" color="#c0c0c0">
			<name x="110" y="110">AwaitingJob</name>
		</location>
		<location id="id31" x="858" y="-170" color="#ffff00">
			<name x="874" y="-221">BeingAssisted</name>
			<label kind="invariant" x="874" y="-204">t &lt;= T_v[id]</label>
		</location>
		<location id="id32" x="390" y="144" color="#00ffff">
			<name x="408" y="110">StartingAssistance</name>
			<committed/>
		</location>
		<init ref="id24"/>
		<transition id="id33">
			<source ref="id32"/>
			<target ref="id22"/>
			<label kind="synchronisation" x="407" y="144">starting_assistance[in.x][in.y]!</label>
		</transition>
		<transition id="id34">
			<source ref="id31"/>
			<target ref="id25"/>
			<label kind="guard" x="875" y="-170">t &gt;= T_v[id]</label>
			<label kind="assignment" x="875" y="-153">set_map(pos, CELL_EMPTY)</label>
			<nail x="1164" y="-170"/>
		</transition>
		<transition id="id35">
			<source ref="id23"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="867" y="-272">starting_assistance[pos.x][pos.y]?</label>
			<label kind="assignment" x="867" y="-255">set_map(pos, CELL_ASSISTED)</label>
		</transition>
		<transition id="id36">
			<source ref="id24"/>
			<target ref="id21"/>
			<label kind="guard" x="212" y="-246">!starting_near_a_fire()</label>
			<label kind="synchronisation" x="212" y="-229">init_done?</label>
			<label kind="assignment" x="212" y="-212">pos = survivors_starting_pos[id],
set_map(pos, CELL_SURVIVOR)</label>
		</transition>
		<transition id="id37">
			<source ref="id30"/>
			<target ref="id32"/>
			<label kind="synchronisation" x="110" y="144">assist_directly[pos.x][pos.y]?</label>
			<label kind="assignment" x="110" y="161">in = target_in_need</label>
		</transition>
		<transition id="id38">
			<source ref="id29"/>
			<target ref="id28"/>
			<label kind="guard" x="331" y="-17">t &gt;= distance(pos, fr)</label>
			<label kind="synchronisation" x="331" y="0">arrived[fr.x][fr.y]!</label>
			<label kind="assignment" x="331" y="17">target_in_need = in</label>
		</transition>
		<transition id="id39">
			<source ref="id28"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="569" y="-17">assist_complete[in.x][in.y]?</label>
			<label kind="assignment" x="569" y="0">set_map(pos, CELL_EMPTY)</label>
		</transition>
		<transition id="id40">
			<source ref="id21"/>
			<target ref="id26"/>
			<label kind="guard" x="620" y="-119">t &gt;= 1 &amp;&amp;
is_exit_near()</label>
			<label kind="assignment" x="620" y="-77">set_map(pos, CELL_EMPTY)</label>
			<nail x="153" y="-119"/>
			<nail x="833" y="-119"/>
		</transition>
		<transition id="id41">
			<source ref="id31"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="867" y="-85">assist_complete[pos.x][pos.y]?</label>
			<label kind="assignment" x="867" y="-68">set_map(pos, CELL_EMPTY)</label>
			<nail x="858" y="-42"/>
		</transition>
		<transition id="id42">
			<source ref="id27"/>
			<target ref="id29"/>
			<label kind="synchronisation" x="110" y="-17">lock_fr[fr.x][fr.y]!</label>
			<label kind="assignment" x="110" y="0">t = 0</label>
		</transition>
		<transition id="id43">
			<source ref="id30"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="102" y="42">go_call_a_fr[pos.x][pos.y]?</label>
			<label kind="assignment" x="102" y="59">fr = target_first_resp,
in = target_in_need</label>
		</transition>
		<transition id="id44">
			<source ref="id23"/>
			<target ref="id25"/>
			<label kind="guard" x="875" y="-323">t &gt;= T_v[id]</label>
			<label kind="assignment" x="875" y="-306">set_map(pos, CELL_EMPTY)</label>
		</transition>
		<transition id="id45">
			<source ref="id22"/>
			<target ref="id26"/>
			<label kind="guard" x="721" y="144">t &gt;= T_zr[id] + distance(pos, in)</label>
			<label kind="synchronisation" x="721" y="161">assist_complete[in.x][in.y]!</label>
			<label kind="assignment" x="721" y="178">set_map(pos, CELL_EMPTY)</label>
			<nail x="705" y="110"/>
		</transition>
		<transition id="id46">
			<source ref="id21"/>
			<target ref="id21"/>
			<label kind="select" x="60" y="-357">i : int[-1, 1],
j : int[-1, 1]</label>
			<label kind="guard" x="59" y="-315">t &gt;= 1 &amp;&amp;
is_move_valid(i, j) &amp;&amp;
!is_exit_near()</label>
			<label kind="assignment" x="60" y="-255">move(i, j),
t = 0</label>
			<label kind="comments" x="195" y="-357">This edge is the only one that resets the clock.
This way the survivor must make one move per time unit</label>
			<nail x="136" y="-230"/>
			<nail x="93" y="-187"/>
		</transition>
		<transition id="id47">
			<source ref="id24"/>
			<target ref="id23"/>
			<label kind="guard" x="510" y="-246">starting_near_a_fire()</label>
			<label kind="synchronisation" x="510" y="-229">init_done?</label>
			<label kind="assignment" x="510" y="-212">pos = survivors_starting_pos[id],
set_map(pos, CELL_IN_NEED)</label>
			<nail x="833" y="-170"/>
			<nail x="833" y="-297"/>
		</transition>
		<transition id="id48">
			<source ref="id21"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="68" y="-102">await_job[pos.x][pos.y]?</label>
			<label kind="assignment" x="68" y="-85">set_map(pos, CELL_ZERO_RESP)</label>
			<nail x="59" y="-93"/>
			<nail x="59" y="110"/>
		</transition>
	</template>
	<template>
		<name>FirstResponder</name>
		<parameter>const first_resp_id_t id</parameter>
		<declaration>/******************************************************************************
 *                                  Variables                                 *
 ******************************************************************************/

clock t = 0;
pos_t pos;

pos_t target; // Target position to move to

/******************************************************************************
 *                                Moving policy                               *
 ******************************************************************************/

bool is_move_valid(int i, int j) {
    pos_t move = {pos.x + i, pos.y + j};

    // We can only move inside the map and we canot stay in the same position
    if (is_pos_in_map(move) &amp;&amp; move != pos) {
        // As a first responder we can move near a fire and we can move only towards empty cells
        return get_map(move) == CELL_EMPTY;
    }

    return false;
}

void move(int i, int j) {
    // Apply movement
    set_map(pos, CELL_EMPTY);
    pos.x += i;
    pos.y += j;
    set_map(pos, CELL_FIRST_RESP);
}

/******************************************************************************
 *                               Other functions                              *
 ******************************************************************************/

// Check if the given relative coordinates points to a survivor in_need
bool is_in_need(int i, int j) {
    pos_t pos_to_check = pos;
    pos_to_check.x += i;
    pos_to_check.y += j;
    return map_check_val(pos_to_check, CELL_IN_NEED);
}

void set_target(int i, int j) {
    target = pos;
    target.x += i;
    target.y += j;
}

void teleport_to_in_need() {
    set_map(pos, CELL_EMPTY);
    pos = target;
    set_map(pos, CELL_FIRST_RESP); // From CELL_ASSISTING back to CELL_FIRST_RESP
}
</declaration>
		<location id="id49" x="-195" y="-76" color="#ffc0cb">
			<name x="-178" y="-127">Assisting</name>
			<label kind="invariant" x="-178" y="-110">t &lt;= T_fr[id]</label>
		</location>
		<location id="id50" x="-552" y="-161" color="#ffa500">
			<name x="-527" y="-178">Available</name>
			<label kind="invariant" x="-527" y="-161">t &lt;= 1</label>
		</location>
		<location id="id51" x="-926" y="-161" color="#ffffff">
			<name x="-909" y="-195">Init</name>
		</location>
		<location id="id52" x="85" y="-255" color="#00ffff">
			<name x="102" y="-306">MovingToInNeed</name>
			<label kind="invariant" x="102" y="-289">t &lt;= distance(pos, target)</label>
		</location>
		<location id="id53" x="-195" y="59" color="#00ff00">
			<committed/>
		</location>
		<location id="id54" x="-195" y="-255" color="#c0c0c0">
			<name x="-178" y="-289">WaitingSurvivorMoveTime</name>
			<label kind="comments" x="-399" y="-357">The first_responder is locked by the zero_responder
and then waits for him to move</label>
		</location>
		<init ref="id51"/>
		<transition id="id55">
			<source ref="id50"/>
			<target ref="id54"/>
			<label kind="synchronisation" x="-450" y="-246">lock_fr[pos.x][pos.y]?</label>
			<nail x="-459" y="-255"/>
		</transition>
		<transition id="id56">
			<source ref="id50"/>
			<target ref="id49"/>
			<label kind="select" x="-527" y="-68">i : int[-1, 1],
j : int[-1, 1]</label>
			<label kind="guard" x="-527" y="-26">is_in_need(i, j)</label>
			<label kind="synchronisation" x="-527" y="-9">starting_assistance[pos.x+i][pos.y+j]!</label>
			<label kind="assignment" x="-527" y="8">set_target(i, j)</label>
			<nail x="-459" y="-76"/>
		</transition>
		<transition id="id57">
			<source ref="id53"/>
			<target ref="id50"/>
			<label kind="assignment" x="-417" y="59">teleport_to_in_need(),
available_fr += 1,
t = 0</label>
			<nail x="-553" y="59"/>
		</transition>
		<transition id="id58">
			<source ref="id50"/>
			<target ref="id50"/>
			<label kind="select" x="-629" y="-366">i : int[-1, 1],
j : int[-1, 1]</label>
			<label kind="guard" x="-629" y="-323">t &gt;= 1 &amp;&amp;
is_move_valid(i, j)</label>
			<label kind="assignment" x="-629" y="-280">move(i, j),
t = 0</label>
			<label kind="comments" x="-867" y="-357">While not busy assisting
survivors, first reponders
can move with a custom
moving policy</label>
			<nail x="-629" y="-238"/>
			<nail x="-552" y="-238"/>
		</transition>
		<transition id="id59">
			<source ref="id52"/>
			<target ref="id49"/>
			<label kind="guard" x="-169" y="-76">t &gt;= distance(pos, target)</label>
			<label kind="synchronisation" x="-170" y="-59">starting_assistance[target.x][target.y]!</label>
			<label kind="assignment" x="-170" y="-42">t = 0</label>
			<nail x="85" y="-76"/>
		</transition>
		<transition id="id60">
			<source ref="id54"/>
			<target ref="id52"/>
			<label kind="synchronisation" x="-186" y="-246">arrived[pos.x][pos.y]?</label>
			<label kind="assignment" x="-186" y="-229">target = target_in_need,
set_map(pos, CELL_ASSISTING),
available_fr -= 1,
t = 0</label>
		</transition>
		<transition id="id61">
			<source ref="id49"/>
			<target ref="id53"/>
			<label kind="guard" x="-187" y="0">t &gt;= T_fr[id]</label>
			<label kind="synchronisation" x="-187" y="17">assist_complete[target.x][target.y]!</label>
		</transition>
		<transition id="id62">
			<source ref="id51"/>
			<target ref="id50"/>
			<label kind="synchronisation" x="-909" y="-153">init_done?</label>
			<label kind="assignment" x="-909" y="-136">pos = first_responders_starting_pos[id],
set_map(pos, CELL_FIRST_RESP),
available_fr += 1</label>
		</transition>
	</template>
	<system>import "/home/alberton/Documents/formal-analysis-of-search-and-rescue-scenarios/visualizer/build/libvisualizer.so" {
    void send_state_via_post_request(int n_cols, int n_rows, int &amp;map[N_CELLS], bool &amp;drone_map[N_CELLS]);
};

meta int flat_map[N_CELLS];
meta bool flat_drone_map[N_CELLS];

void prepare_flat_map() {
    for (x : int[0, N_COLS-1]) {
        for (y : int[0, N_ROWS-1]) {
            // Flatten the maps
            flat_map[x*N_COLS + y] = map[x][y];
            flat_drone_map[x*N_COLS + y] = drone_map[x][y];
        }
    }
}

void send_state() {
    prepare_flat_map();
    send_state_via_post_request(N_COLS, N_ROWS, flat_map, flat_drone_map);
}

// before_update { send_state() }
// after_update { send_state() }

system FirstResponder, Initializer;

/* TODOs
 * [X] All payload passing must happen when channels are triggered
 *     Payload passing happens in:
 *     - Drone -assist_directly-&gt; Survivor: target_in_need
 *     - Drone -go_call_a_fr-&gt; Survivor: target_first_resp, target_in_need
 *     - Survivor -zr_arrived-&gt; FirstResponder: target_in_need
 * [X] Make all agents update their status in the map (e.g. the drone should not update the cell of a survivor from survivor to zero responder)
 * [ ] Move Drone decison making policy into a function (possible?). This way it should be easy to define multiple ones
 * [ ] Change go_call_a_fr in first_responder. This should disappear if we model all movements
 * [ ] Make drone move selection ranges be relative instead of global, like in first_reponders
 * [ ] Model the death of an in_need when occurring before being saved and notify who is helping to stop (this will most likely require a channel)
 * [X] Abstract is_fire_near, is_exit_near and similar functions into a single implementation to reduce code duplication
 * [X] Rename radius_cell_check to something better, improve comment
 * [X] Color the locations
 * [X] Change the Survivor moving policy -&gt; Improved Federico's policy
 * [X] When a survivor assist directly he does not send starting_assistance signal
 *
 * [ ] Read again the assignment and check model consistency
 * [ ] Read again the prof's answers to email questions and check consistency
 */</system>
	<queries>
		<option key="--hashtable-size" value="32"/>
		<option key="--statespace-consumption" value="2"/>
		<query>
			<formula>A[] not deadlock</formula>
			<comment/>
		</query>
		<query>
			<formula>A[] forall (i : drone_id_t) forall (j : drone_id_t) (i != j &amp;&amp; not Drone(i).Init &amp;&amp; not Drone(j).Init) imply (Drone(i).pos.x != Drone(j).pos.x || Drone(i).pos.y != Drone(j).pos.y)</formula>
			<comment>Drones cannot occupy the same cell at the same time</comment>
		</query>
		<query>
			<formula>A[] forall (i : survivor_id_t) forall (j : survivor_id_t) (i != j &amp;&amp; not Survivor(i).Init &amp;&amp; not Survivor(j).Init) imply (Survivor(i).pos.x != Survivor(j).pos.x || Survivor(i).pos.y != Survivor(j).pos.y)</formula>
			<comment>Survivors cannot occupy the same cell at the same time</comment>
		</query>
		<query>
			<formula>A[] forall (i : first_resp_id_t) forall (j : first_resp_id_t) (i != j &amp;&amp; not FirstResponder(i).Init &amp;&amp; not FirstResponder(j).Init) imply (FirstResponder(i).pos.x != FirstResponder(j).pos.x || FirstResponder(i).pos.y != FirstResponder(j).pos.y)</formula>
			<comment/>
		</query>
		<query>
			<formula>A[] forall (i : survivor_id_t) forall (j : first_resp_id_t) (not Survivor(i).Init &amp;&amp; not Survivor(i).Safe &amp;&amp; not Survivor(i).Dead &amp;&amp; not FirstResponder(j).Init) imply (Survivor(i).pos.x != FirstResponder(j).pos.x || Survivor(i).pos.y != FirstResponder(j).pos.y)</formula>
			<comment>Survivors and first responders cannot occupy the same cell at the same time</comment>
		</query>
	</queries>
</nta>
